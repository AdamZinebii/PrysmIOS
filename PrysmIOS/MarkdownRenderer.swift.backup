import SwiftUI
import Foundation

// MARK: - Enhanced Markdown Text View
struct MarkdownText: View {
    let markdown: String
    let font: Font
    let color: Color
    let lineLimit: Int?
    let alignment: TextAlignment
    
    init(_ markdown: String, 
         font: Font = .body, 
         color: Color = .primary, 
         lineLimit: Int? = nil, 
         alignment: TextAlignment = .leading) {
        self.markdown = markdown
        self.font = font
        self.color = color
        self.lineLimit = lineLimit
        self.alignment = alignment
    }
    
    var body: some View {
        Group {
            if #available(iOS 15.0, *) {
                // Use custom parsing for better control
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(parseMarkdownContent(markdown), id: \.id) { section in
                        MarkdownSectionView(section: section, font: font, color: color)
                    }
                }
            } else {
                // Fallback for older iOS versions
                Text(formatMarkdownForOlderVersions(markdown))
                    .font(font)
                    .foregroundColor(color)
                    .lineLimit(lineLimit)
                    .multilineTextAlignment(alignment)
            }
        }
    }
    
    private func parseMarkdownContent(_ content: String) -> [MarkdownSection] {
        let lines = content.components(separatedBy: .newlines)
        var sections: [MarkdownSection] = []
        var currentSection: MarkdownSection?
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            
            // Skip empty lines
            if trimmedLine.isEmpty {
                continue
            }
            
            if trimmedLine.hasPrefix("**") && trimmedLine.hasSuffix("**") && trimmedLine.count > 4 && !trimmedLine.contains("‚Ä¢ ") && !trimmedLine.contains("- ") {
                // Bold header section (only if it's a standalone header, not mixed with bullets)
                if let current = currentSection {
                    sections.append(current)
                }
                let boldContent = String(trimmedLine.dropFirst(2).dropLast(2))
                currentSection = MarkdownSection(
                    id: UUID(),
                    type: .boldHeader,
                    content: boldContent,
                    items: []
                )
            } else if trimmedLine.hasPrefix("‚Ä¢ ") || trimmedLine.hasPrefix("- ") {
                // Bullet point (handle both ‚Ä¢ and - for robustness)
                let bulletContent = trimmedLine.hasPrefix("‚Ä¢ ") ? 
                    String(trimmedLine.dropFirst(2)) : 
                    String(trimmedLine.dropFirst(2))
                
                if currentSection == nil || currentSection?.type != .bulletList {
                    if let current = currentSection {
                        sections.append(current)
                    }
                    currentSection = MarkdownSection(
                        id: UUID(),
                        type: .bulletList,
                        content: "",
                        items: []
                    )
                }
                currentSection?.items.append(bulletContent)
            } else {
                // Regular text paragraph
                if currentSection == nil || currentSection?.type != .paragraph {
                    if let current = currentSection {
                        sections.append(current)
                    }
                    currentSection = MarkdownSection(
                        id: UUID(),
                        type: .paragraph,
                        content: trimmedLine,
                        items: []
                    )
                } else {
                    currentSection?.content += " " + trimmedLine
                }
            }
        }
        
        if let current = currentSection {
            sections.append(current)
        }
        
        return sections
    }
    
    // New function to parse inline bold formatting
    private func parseInlineFormattingText(_ text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var currentText = text
        
        while !currentText.isEmpty {
            var foundFormatting = false
            
            // Find the next occurrence of any formatting
            var nextTripleRange: Range<String.Index>?
            var nextDoubleRange: Range<String.Index>?
            
            // Check for triple asterisks first: ***text***
            if let tripleRange = currentText.range(of: "\\*\\*\\*([^*]+?)\\*\\*\\*", options: .regularExpression) {
                nextTripleRange = tripleRange
            }
            
            // Check for double asterisks: **text** (but not part of triple)
            if let doubleRange = currentText.range(of: "\\*\\*([^*]+?)\\*\\*", options: .regularExpression) {
                // Make sure this double asterisk is not part of a triple asterisk
                let doubleStart = doubleRange.lowerBound
                let beforeDouble = currentText[..<doubleStart]
                let afterDoubleStart = currentText.index(doubleRange.lowerBound, offsetBy: -1, limitedBy: currentText.startIndex)
                let afterDoubleEnd = currentText.index(doubleRange.upperBound, offsetBy: 0, limitedBy: currentText.endIndex)
                
                var isPartOfTriple = false
                if let beforeIdx = afterDoubleStart, beforeIdx >= currentText.startIndex {
                    if currentText[beforeIdx] == "*" { isPartOfTriple = true }
                }
                if let afterIdx = afterDoubleEnd, afterIdx < currentText.endIndex {
                    if currentText[afterIdx] == "*" { isPartOfTriple = true }
                }
                
                if !isPartOfTriple {
                    nextDoubleRange = doubleRange
                }
            }
            
            // Determine which formatting comes first
            if let tripleRange = nextTripleRange, let doubleRange = nextDoubleRange {
                // Both found, use the one that comes first
                if tripleRange.lowerBound < doubleRange.lowerBound {
                    // Process triple asterisk
                    let before = String(currentText[..<tripleRange.lowerBound])
                    if !before.isEmpty {
                        segments.append(TextSegment(text: before))
                    }
                    
                    let tripleText = String(currentText[tripleRange])
                    let cleanText = tripleText.replacingOccurrences(of: "***", with: "")
                    segments.append(TextSegment(text: cleanText, isImportant: true))
                    
                    currentText = String(currentText[tripleRange.upperBound...])
                    foundFormatting = true
                } else {
                    // Process double asterisk
                    let before = String(currentText[..<doubleRange.lowerBound])
                    if !before.isEmpty {
                        segments.append(TextSegment(text: before))
                    }
                    
                    let doubleText = String(currentText[doubleRange])
                    let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                    segments.append(TextSegment(text: cleanText, isBold: true))
                    
                    currentText = String(currentText[doubleRange.upperBound...])
                    foundFormatting = true
                }
            } else if let tripleRange = nextTripleRange {
                // Only triple found
                let before = String(currentText[..<tripleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let tripleText = String(currentText[tripleRange])
                let cleanText = tripleText.replacingOccurrences(of: "***", with: "")
                segments.append(TextSegment(text: cleanText, isImportant: true))
                
                currentText = String(currentText[tripleRange.upperBound...])
                foundFormatting = true
            } else if let doubleRange = nextDoubleRange {
                // Only double found
                let before = String(currentText[..<doubleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let doubleText = String(currentText[doubleRange])
                let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                segments.append(TextSegment(text: cleanText, isBold: true))
                
                currentText = String(currentText[doubleRange.upperBound...])
                foundFormatting = true
            }
            
            if !foundFormatting {
                // No more formatting, add remaining text
                segments.append(TextSegment(text: currentText))
                break
            }
        }
        
        return segments.isEmpty ? [TextSegment(text: text)] : segments
    }
    
    // Helper function for double bold only
    private func parseDoubleBold(_ text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var currentText = text
        
        while !currentText.isEmpty {
            if let doubleRange = currentText.range(of: "\\*\\*([^*]+?)\\*\\*", options: .regularExpression) {
                let before = String(currentText[..<doubleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let doubleText = String(currentText[doubleRange])
                let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                segments.append(TextSegment(text: cleanText, isBold: true))
                
                currentText = String(currentText[doubleRange.upperBound...])
            } else {
                segments.append(TextSegment(text: currentText))
                break
            }
        }
        
        return segments.isEmpty ? [TextSegment(text: text)] : segments
    }
    
    private func formatMarkdownForOlderVersions(_ text: String) -> String {
        // Basic markdown formatting removal for older iOS versions
        return text
            .replacingOccurrences(of: "***", with: "")
            .replacingOccurrences(of: "**", with: "")
            .replacingOccurrences(of: "*", with: "")
            .replacingOccurrences(of: "###", with: "")
            .replacingOccurrences(of: "##", with: "")
            .replacingOccurrences(of: "#", with: "")
            .replacingOccurrences(of: "<<[^>]+>>", with: "", options: .regularExpression)
    }
}

// MARK: - Text Segment Model for Inline Bold and URLs
struct TextSegment {
    let text: String
    let isBold: Bool
    let isImportant: Bool
    let isURL: Bool
    let url: String?
    let isImageURL: Bool
    
    init(text: String, isBold: Bool = false, isImportant: Bool = false, isURL: Bool = false, url: String? = nil, isImageURL: Bool = false) {
        self.text = text
        self.isBold = isBold
        self.isImportant = isImportant
        self.isURL = isURL
        self.url = url
        self.isImageURL = isImageURL
    }
}

// MARK: - Markdown Section Models
struct MarkdownSection: Identifiable {
    let id: UUID
    let type: MarkdownSectionType
    var content: String
    var items: [String]
}

enum MarkdownSectionType {
    case boldHeader
    case paragraph
    case bulletList
}

// MARK: - Markdown Section View
struct MarkdownSectionView: View {
    let section: MarkdownSection
    let font: Font
    let color: Color
    
    var body: some View {
        switch section.type {
        case .boldHeader:
            HStack {
                Text(section.content)
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(color)
                Spacer()
            }
            .padding(.top, 8)
            .padding(.bottom, 4)
            
        case .paragraph:
            InlineFormattedText(section.content, font: font, color: color)
                .multilineTextAlignment(.leading)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.bottom, 4)
                
        case .bulletList:
            VStack(alignment: .leading, spacing: 6) {
                ForEach(Array(section.items.enumerated()), id: \.offset) { index, item in
                    HStack(alignment: .top, spacing: 8) {
                        Circle()
                            .fill(Color.primary.opacity(0.6))
                            .frame(width: 4, height: 4)
                            .padding(.top, 8)
                        
                        InlineFormattedText(item, font: font, color: color)
                            .multilineTextAlignment(.leading)
                            .fixedSize(horizontal: false, vertical: true)
                        
                        Spacer()
                    }
                }
            }
            .padding(.bottom, 8)
        }
    }
    
    private func extractURLsFromText(_ text: String) -> [String] {
        var urls: [String] = []
        var currentText = text
        
        while !currentText.isEmpty {
            if let urlRange = currentText.range(of: "<<([^>]+)>>", options: .regularExpression) {
                let urlText = String(currentText[urlRange])
                let cleanURL = urlText.replacingOccurrences(of: "<<", with: "").replacingOccurrences(of: ">>", with: "")
                urls.append(cleanURL)
                currentText = String(currentText[urlRange.upperBound...])
            } else {
                break
            }
        }
        
        return urls
    }
}

// MARK: - Article Thumbnails View
struct ArticleThumbnailsView: View {
    let urls: [String]
    @State private var matchingArticles: [ArticleData] = []
    
    var body: some View {
        Group {
            if !matchingArticles.isEmpty {
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Image(systemName: "photo.on.rectangle")
                            .font(.system(size: 12))
                            .foregroundColor(.secondary)
                        Text("Sources")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    
                    LazyVGrid(columns: [
                        GridItem(.flexible(), spacing: 6),
                        GridItem(.flexible(), spacing: 6),
                        GridItem(.flexible(), spacing: 6)
                    ], spacing: 6) {
                        ForEach(Array(matchingArticles.enumerated()), id: \.offset) { index, article in
                            if let thumbnailUrl = article.thumbnail, !thumbnailUrl.isEmpty {
                                ArticleSourceThumbnail(
                                    article: article,
                                    size: 60
                                )
                            }
                        }
                    }
                }
                .padding(12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(Color(.systemGray6))
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color(.systemGray4), lineWidth: 0.5)
                        )
                )
            }
        }
        .onAppear {
            findMatchingArticles()
        }
        .onChange(of: urls) { _ in
            findMatchingArticles()
        }
    }
    
    private func findMatchingArticles() {
        let articleData = AIFeedService.shared.articleData
        var foundArticles: [ArticleData] = []
        
        print("üîç Looking for articles matching URLs: \(urls)")
        
        for url in urls {
            // Search through all topics and articles
            for (topicName, articles) in articleData {
                for article in articles {
                    if article.link == url {
                        foundArticles.append(article)
                        print("‚úÖ Found matching article: \(article.title) for URL: \(url)")
                        break
                    }
                }
            }
        }
        
        // Remove duplicates and limit to 6
        let uniqueArticles = Array(Set(foundArticles.map { $0.id }))
            .compactMap { id in foundArticles.first { $0.id == id } }
            .prefix(6)
        
        matchingArticles = Array(uniqueArticles)
        print("üìä Final matching articles count: \(matchingArticles.count)")
    }
}

// MARK: - Article Source Thumbnail
struct ArticleSourceThumbnail: View {
    let article: ArticleData
    let size: CGFloat
    @State private var showingFullArticle = false
    
    var body: some View {
        Button(action: {
            // Haptic feedback
            let impactFeedback = UIImpactFeedbackGenerator(style: .light)
            impactFeedback.impactOccurred()
            
            // Open article URL
            if let url = URL(string: article.link) {
                UIApplication.shared.open(url)
            }
        }) {
            VStack(spacing: 4) {
                // Thumbnail image
                if let thumbnailUrl = article.thumbnail {
                    AsyncImage(url: URL(string: thumbnailUrl)) { phase in
                        switch phase {
                        case .empty:
                            RoundedRectangle(cornerRadius: 6)
                                .fill(Color(.systemGray5))
                                .frame(width: size, height: size)
                                .overlay(
                                    ProgressView()
                                        .scaleEffect(0.6)
                                        .tint(.gray)
                                )
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: size, height: size)
                                .clipped()
                                .clipShape(RoundedRectangle(cornerRadius: 6))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 6)
                                        .stroke(Color(.systemGray4), lineWidth: 0.5)
                                )
                        case .failure(_):
                            RoundedRectangle(cornerRadius: 6)
                                .fill(Color(.systemGray5))
                                .frame(width: size, height: size)
                                .overlay(
                                    Image(systemName: "doc.text")
                                        .font(.system(size: size * 0.3))
                                        .foregroundColor(.gray)
                                )
                        @unknown default:
                            EmptyView()
                        }
                    }
                }
                
                // Source label
                Text(article.source)
                    .font(.system(size: 9, weight: .medium))
                    .foregroundColor(.secondary)
                    .lineLimit(1)
                    .frame(width: size)
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

// MARK: - Enhanced Inline Formatted Text View with URL Support
struct InlineFormattedText: View {
    let text: String
    let font: Font
    let color: Color
    
    init(_ text: String, font: Font, color: Color) {
        self.text = text
        self.font = font
        self.color = color
    }
    
    var body: some View {
        let segments = parseInlineFormatting(text)
        
        // Create a flowing text layout with inline buttons and thumbnails
        return FlowingTextViewWithThumbnails(segments: segments, font: font, color: color)
    }
    
    private func parseInlineFormatting(_ text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var currentText = text
        
        while !currentText.isEmpty {
            // Check for IMG URL patterns first: <<IMG:URL>>
            if let imgUrlRange = currentText.range(of: "<<IMG:([^>]+)>>", options: .regularExpression) {
                // Add text before the IMG URL
                let beforeURL = String(currentText[..<imgUrlRange.lowerBound])
                if !beforeURL.isEmpty {
                    segments.append(contentsOf: parseInlineFormattingText(beforeURL))
                }
                
                // Extract the IMG URL
                let imgUrlText = String(currentText[imgUrlRange])
                let cleanURL = imgUrlText.replacingOccurrences(of: "<<IMG:", with: "").replacingOccurrences(of: ">>", with: "")
                segments.append(TextSegment(text: "", isURL: true, url: cleanURL, isImageURL: true))
                
                // Continue with the rest of the text
                currentText = String(currentText[imgUrlRange.upperBound...])
            }
            // Check for regular URL patterns: <<URL>>
            else if let urlRange = currentText.range(of: "<<([^>]+)>>", options: .regularExpression) {
                // Add text before the URL
                let beforeURL = String(currentText[..<urlRange.lowerBound])
                if !beforeURL.isEmpty {
                    segments.append(contentsOf: parseInlineFormattingText(beforeURL))
                }
                
                // Extract the regular URL
                let urlText = String(currentText[urlRange])
                let cleanURL = urlText.replacingOccurrences(of: "<<", with: "").replacingOccurrences(of: ">>", with: "")
                segments.append(TextSegment(text: "", isURL: true, url: cleanURL, isImageURL: false))
                
                // Continue with the rest of the text
                currentText = String(currentText[urlRange.upperBound...])
            } else {
                // No more URLs, parse the rest for formatting
                segments.append(contentsOf: parseInlineFormattingText(currentText))
                break
            }
        }
        
        return segments.isEmpty ? [TextSegment(text: text)] : segments
    }
    
    private func parseInlineFormattingText(_ text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var currentText = text
        
        while !currentText.isEmpty {
            var foundFormatting = false
            
            // Find the next occurrence of any formatting
            var nextTripleRange: Range<String.Index>?
            var nextDoubleRange: Range<String.Index>?
            
            // Check for triple asterisks first: ***text***
            if let tripleRange = currentText.range(of: "\\*\\*\\*([^*]+?)\\*\\*\\*", options: .regularExpression) {
                nextTripleRange = tripleRange
            }
            
            // Check for double asterisks: **text** (but not part of triple)
            if let doubleRange = currentText.range(of: "\\*\\*([^*]+?)\\*\\*", options: .regularExpression) {
                // Make sure this double asterisk is not part of a triple asterisk
                let doubleStart = doubleRange.lowerBound
                let beforeDouble = currentText[..<doubleStart]
                let afterDoubleStart = currentText.index(doubleRange.lowerBound, offsetBy: -1, limitedBy: currentText.startIndex)
                let afterDoubleEnd = currentText.index(doubleRange.upperBound, offsetBy: 0, limitedBy: currentText.endIndex)
                
                var isPartOfTriple = false
                if let beforeIdx = afterDoubleStart, beforeIdx >= currentText.startIndex {
                    if currentText[beforeIdx] == "*" { isPartOfTriple = true }
                }
                if let afterIdx = afterDoubleEnd, afterIdx < currentText.endIndex {
                    if currentText[afterIdx] == "*" { isPartOfTriple = true }
                }
                
                if !isPartOfTriple {
                    nextDoubleRange = doubleRange
                }
            }
            
            // Determine which formatting comes first
            if let tripleRange = nextTripleRange, let doubleRange = nextDoubleRange {
                // Both found, use the one that comes first
                if tripleRange.lowerBound < doubleRange.lowerBound {
                    // Process triple asterisk
                    let before = String(currentText[..<tripleRange.lowerBound])
                    if !before.isEmpty {
                        segments.append(TextSegment(text: before))
                    }
                    
                    let tripleText = String(currentText[tripleRange])
                    let cleanText = tripleText.replacingOccurrences(of: "***", with: "")
                    segments.append(TextSegment(text: cleanText, isImportant: true))
                    
                    currentText = String(currentText[tripleRange.upperBound...])
                    foundFormatting = true
                } else {
                    // Process double asterisk
                    let before = String(currentText[..<doubleRange.lowerBound])
                    if !before.isEmpty {
                        segments.append(TextSegment(text: before))
                    }
                    
                    let doubleText = String(currentText[doubleRange])
                    let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                    segments.append(TextSegment(text: cleanText, isBold: true))
                    
                    currentText = String(currentText[doubleRange.upperBound...])
                    foundFormatting = true
                }
            } else if let tripleRange = nextTripleRange {
                // Only triple found
                let before = String(currentText[..<tripleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let tripleText = String(currentText[tripleRange])
                let cleanText = tripleText.replacingOccurrences(of: "***", with: "")
                segments.append(TextSegment(text: cleanText, isImportant: true))
                
                currentText = String(currentText[tripleRange.upperBound...])
                foundFormatting = true
            } else if let doubleRange = nextDoubleRange {
                // Only double found
                let before = String(currentText[..<doubleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let doubleText = String(currentText[doubleRange])
                let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                segments.append(TextSegment(text: cleanText, isBold: true))
                
                currentText = String(currentText[doubleRange.upperBound...])
                foundFormatting = true
            }
            
            if !foundFormatting {
                // No more formatting, add remaining text
                segments.append(TextSegment(text: currentText))
                break
            }
        }
        
        return segments.isEmpty ? [TextSegment(text: text)] : segments
    }
    
    // Helper function for double bold only
    private func parseDoubleBold(_ text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var currentText = text
        
        while !currentText.isEmpty {
            if let doubleRange = currentText.range(of: "\\*\\*([^*]+?)\\*\\*", options: .regularExpression) {
                let before = String(currentText[..<doubleRange.lowerBound])
                if !before.isEmpty {
                    segments.append(TextSegment(text: before))
                }
                
                let doubleText = String(currentText[doubleRange])
                let cleanText = doubleText.replacingOccurrences(of: "**", with: "")
                segments.append(TextSegment(text: cleanText, isBold: true))
                
                currentText = String(currentText[doubleRange.upperBound...])
            } else {
                segments.append(TextSegment(text: currentText))
                break
            }
        }
        
        return segments.isEmpty ? [TextSegment(text: text)] : segments
    }
}

// MARK: - Flowing Text View with Inline Thumbnails
struct FlowingTextViewWithThumbnails: View {
    let segments: [TextSegment]
    let font: Font
    let color: Color
    @State private var articleData: [String: ArticleData] = [:]
    
    var body: some View {
        let elements = buildTextAndThumbnailElements()
        let hasImages = elements.contains { if case .thumbnail(_) = $0 { return true } else { return false } }
        
        Group {
            if hasImages {
                // Layout horizontal avec texte √† gauche et images √† droite
                HStack(alignment: .top, spacing: 12) {
                    // Texte √† gauche - une seule vue Text concat√©n√©e pour une typographie coh√©rente
                    buildConcatenatedText(from: elements)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Images √† droite
                    VStack(alignment: .trailing, spacing: 8) {
                        ForEach(Array(elements.enumerated()), id: \.offset) { index, element in
                            if case .thumbnail(let url) = element {
                                if let article = articleData[url] {
                                    InlineArticleThumbnail(article: article)
                                        .onAppear {
                                            print("üñºÔ∏è Rendering thumbnail for URL: \(url)")
                                            print("üìÑ Article: \(article.title)")
                                            print("üîó Thumbnail URL: \(article.thumbnail ?? "nil")")
                                        }
                                } else {
                                    EmptyView()
                                        .onAppear {
                                            print("‚ùå No article found for URL: \(url)")
                                            print("üîç Available URLs: \(Array(articleData.keys).prefix(3))")
                                        }
                                }
                            }
                        }
                    }
                }
            } else {
                // Pas d'images, layout normal - une seule vue Text concat√©n√©e
                buildConcatenatedText(from: segments)
            }
        }
        .onAppear {
            loadArticleData()
        }
    }
    
    // Nouvelle fonction pour construire le texte avec des boutons inline pour tous les types d'URLs
    private func buildTextWithInlineButtons(from segments: [TextSegment]) -> some View {
        HStack(alignment: .firstTextBaseline, spacing: 2) {
            ForEach(Array(segments.enumerated()), id: \.offset) { segmentIndex, segment in
                if segment.isURL, let urlString = segment.url, let url = URL(string: urlString) {
                    // Afficher un bouton favicon pour tous les types d'URLs
                    InlineFaviconButton(url: url, font: font)
                        .onAppear {
                            if segment.isImageURL {
                                print("üñºÔ∏è Rendering favicon for IMG URL: \(urlString)")
                            } else {
                                print("üîó Rendering favicon for regular URL: \(urlString)")
                            }
                        }
                } else if !segment.text.isEmpty {
                    // Text normal - create Text view properly
                    Group {
                        if segment.isImportant {
                            Text(segment.text)
                                .fontWeight(.semibold)
                                .font(font)
                                .foregroundColor(color)
                        } else if segment.isBold {
                            Text(segment.text)
                                .fontWeight(.bold)
                                .font(font)
                                .foregroundColor(color)
                        } else {
                            Text(segment.text)
                                .fontWeight(.regular)
                                .font(font)
                                .foregroundColor(color)
                        }
                    }
                }
            }
        }
    }
    
    // Fonction pour construire le texte simple (sans images)
    private func buildConcatenatedText(from segments: [TextSegment]) -> some View {
        return buildTextWithInlineButtons(from: segments)
    }
    
    // Version surcharg√©e pour les √©l√©ments (avec URLs s√©par√©es)
    private func buildConcatenatedText(from elements: [TextElement]) -> some View {
        HStack(alignment: .firstTextBaseline, spacing: 2) {
            ForEach(Array(elements.enumerated()), id: \.offset) { index, element in
                if case .text(let textSegments) = element {
                    // Build the text with inline buttons for all URL types
                    buildTextWithInlineButtons(from: textSegments)
                }
            }
        }
    }
    
    private func buildTextAndThumbnailElements() -> [TextElement] {
        var elements: [TextElement] = []
        var currentTextSegments: [TextSegment] = []
        
        for segment in segments {
            if segment.isURL && segment.isImageURL {
                // Add current text segments if any
                if !currentTextSegments.isEmpty {
                    currentTextSegments.append(segment) // Include the IMG URL in the text
                    elements.append(.text(currentTextSegments))
                    currentTextSegments = []
                }
                
                // Add thumbnail element only for IMG URLs
                if let url = segment.url {
                    elements.append(.thumbnail(url))
                    print("üñºÔ∏è Adding thumbnail for IMG URL: \(url)")
                }
            } else if segment.isURL && !segment.isImageURL {
                // Regular URL - include in text but don't create thumbnail
                currentTextSegments.append(segment)
                print("üîó Adding regular link (no thumbnail): \(segment.url ?? "unknown")")
            } else {
                // Regular text segment
                currentTextSegments.append(segment)
            }
        }
        
        // Add remaining text segments
        if !currentTextSegments.isEmpty {
            elements.append(.text(currentTextSegments))
        }
        
        return elements
    }
    
    private func loadArticleData() {
        let allArticleData = AIFeedService.shared.articleData
        var urlToArticle: [String: ArticleData] = [:]
        
        print("üîç Loading article data for thumbnail matching...")
        print("üìä Total topics in articleData: \(allArticleData.count)")
        
        // Build lookup dictionary from URL to Article
        var totalArticles = 0
        var articlesWithThumbnails = 0
        
        for (topicName, articles) in allArticleData {
            print("üìö Topic '\(topicName)': \(articles.count) articles")
            totalArticles += articles.count
            
            for article in articles {
                urlToArticle[article.link] = article
                
                if let thumbnail = article.thumbnail, !thumbnail.isEmpty {
                    articlesWithThumbnails += 1
                    print("üñºÔ∏è Article with thumbnail: '\(article.title)' -> \(article.link)")
                } else {
                    print("‚ùå No thumbnail for: '\(article.title)' -> \(article.link)")
                }
            }
        }
        
        print("üìà Summary: \(totalArticles) total articles, \(articlesWithThumbnails) with thumbnails")
        print("üîó URLs in lookup dictionary: \(urlToArticle.keys.count)")
        
        articleData = urlToArticle
    }
    
    enum TextElement {
        case text([TextSegment])
        case thumbnail(String) // URL
    }
}

// MARK: - Enhanced Inline Article Thumbnail with Better Error Detection
struct InlineArticleThumbnail: View {
    let article: ArticleData
    @State private var showingFullScreenImage = false
    @State private var imageLoadingState: ImageLoadingState = .loading
    
    enum ImageLoadingState {
        case loading
        case success(UIImage)
        case failed(ImageFailureReason)
    }
    
    enum ImageFailureReason {
        case invalidURL
        case networkError(String)
        case notAnImage
        case blocked
        case tooSmall
        case unknown
        
        var icon: String {
            switch self {
            case .invalidURL: return "link.icloud.fill"
            case .networkError: return "wifi.exclamationmark"
            case .notAnImage: return "doc.text.fill"
            case .blocked: return "hand.raised.fill"
            case .tooSmall: return "photo.fill.on.rectangle.fill"
            case .unknown: return "questionmark.circle.fill"
            }
        }
        
        var description: String {
            switch self {
            case .invalidURL: return "Invalid URL"
            case .networkError(let message): return "Network: \(message)"
            case .notAnImage: return "Not an image"
            case .blocked: return "Site blocked"
            case .tooSmall: return "Image too small"
            case .unknown: return "Unknown error"
            }
        }
    }
    
    var body: some View {
        Group {
            if let thumbnailUrl = article.thumbnail, !thumbnailUrl.isEmpty {
                VStack(spacing: 4) {
                    // Image avec d√©tection d'erreur am√©lior√©e
                    Group {
                        switch imageLoadingState {
                        case .loading:
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color(.systemGray5))
                                .frame(width: 80, height: 80)
                                .overlay(
                                    ProgressView()
                                        .scaleEffect(0.8)
                                        .tint(.gray)
                                )
                        case .success(let uiImage):
                            Button(action: {
                                let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                                impactFeedback.impactOccurred()
                                showingFullScreenImage = true
                            }) {
                                Image(uiImage: uiImage)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 80, height: 80)
                                    .clipped()
                                    .clipShape(RoundedRectangle(cornerRadius: 8))
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.green.opacity(0.3), lineWidth: 1)
                                    )
                            }
                            .buttonStyle(PlainButtonStyle())
                            .fullScreenCover(isPresented: $showingFullScreenImage) {
                                FullScreenImageView(
                                    imageUrl: thumbnailUrl,
                                    article: article,
                                    isPresented: $showingFullScreenImage
                                )
                            }
                        case .failed(_):
                            // Si l'image ne peut pas √™tre charg√©e, n'affiche rien
                            EmptyView()
                        }
                    }
                    .onAppear {
                        loadImageWithEnhancedDetection(from: thumbnailUrl)
                    }
                }
            } else {
                EmptyView()
                    .onAppear {
                        print("‚ùå No thumbnail for article: \(article.title)")
                    }
            }
        }
    }
    
    private func loadImageWithEnhancedDetection(from urlString: String) {
        guard let url = URL(string: urlString) else {
            print("‚ùå Invalid URL: \(urlString)")
            imageLoadingState = .failed(.invalidURL)
            return
        }
        
        print("üîç Loading image from: \(urlString)")
        
        var request = URLRequest(url: url)
        request.setValue("Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15", forHTTPHeaderField: "User-Agent")
        request.timeoutInterval = 10.0
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                // V√©rifier les erreurs r√©seau
                if let error = error {
                    print("‚ùå Network error: \(error.localizedDescription)")
                    let reason: ImageFailureReason
                    if error.localizedDescription.contains("blocked") || error.localizedDescription.contains("forbidden") {
                        reason = .blocked
                    } else {
                        reason = .networkError(error.localizedDescription)
                    }
                    imageLoadingState = .failed(reason)
                    return
                }
                
                // V√©rifier la r√©ponse HTTP
                if let httpResponse = response as? HTTPURLResponse {
                    print("üì° HTTP Status: \(httpResponse.statusCode) for \(urlString)")
                    
                    if httpResponse.statusCode == 403 || httpResponse.statusCode == 451 {
                        print("üö´ Site blocked (HTTP \(httpResponse.statusCode))")
                        imageLoadingState = .failed(.blocked)
                        return
                    }
                    
                    if httpResponse.statusCode >= 400 {
                        print("‚ùå HTTP Error \(httpResponse.statusCode)")
                        imageLoadingState = .failed(.networkError("HTTP \(httpResponse.statusCode)"))
                        return
                    }
                }
                
                // V√©rifier les donn√©es
                guard let data = data else {
                    print("‚ùå No data received")
                    imageLoadingState = .failed(.unknown)
                    return
                }
                
                print("üìä Received \(data.count) bytes")
                
                // V√©rifier la taille minimale
                if data.count < 500 {
                    print("‚ùå Image too small: \(data.count) bytes")
                    imageLoadingState = .failed(.tooSmall)
                    return
                }
                
                // V√©rifier si c'est vraiment une image
                guard let image = UIImage(data: data) else {
                    print("‚ùå Data is not a valid image")
                    imageLoadingState = .failed(.notAnImage)
                    return
                }
                
                // V√©rifier les dimensions de l'image
                if image.size.width < 50 || image.size.height < 50 {
                    print("‚ùå Image dimensions too small: \(image.size)")
                    imageLoadingState = .failed(.tooSmall)
                    return
                }
                
                print("‚úÖ Image loaded successfully: \(image.size)")
                imageLoadingState = .success(image)
            }
        }.resume()
    }
}

// MARK: - Full Screen Image View
struct FullScreenImageView: View {
    let imageUrl: String
    let article: ArticleData
    @Binding var isPresented: Bool
    
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
            
            VStack {
                // Header with close button and article info
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(article.title)
                            .font(.headline)
                            .foregroundColor(.white)
                            .lineLimit(2)
                        
                        Button(action: {
                            if let url = URL(string: article.link) {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            HStack(spacing: 4) {
                                Text(article.source)
                                    .font(.caption)
                                    .foregroundColor(.blue)
                                Image(systemName: "arrow.up.right.square")
                                    .font(.caption)
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                    
                    Spacer()
                    
                    Button(action: {
                        isPresented = false
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .background(Circle().fill(Color.black.opacity(0.6)))
                    }
                }
                .padding()
                
                Spacer()
                
                // Main image
                AsyncImage(url: URL(string: imageUrl)) { phase in
                    switch phase {
                    case .empty:
                        ProgressView()
                            .scaleEffect(1.5)
                            .tint(.white)
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .clipped()
                    case .failure(_):
                        VStack(spacing: 16) {
                            Image(systemName: "photo")
                                .font(.system(size: 60))
                                .foregroundColor(.gray)
                            Text("Image could not be loaded")
                                .font(.body)
                                .foregroundColor(.gray)
                        }
                    @unknown default:
                        EmptyView()
                    }
                }
                
                Spacer()
            }
        }
        .gesture(
            // Allow swipe down to dismiss
            DragGesture()
                .onEnded { gesture in
                    if gesture.translation.height > 100 {
                        isPresented = false
                    }
                }
        )
    }
}

// MARK: - Inline Favicon Button Component
struct InlineFaviconButton: View {
    let url: URL
    let font: Font
    @State private var faviconImage: UIImage?
    @State private var isLoading = true
    
    // Calculate size based on font
    private var buttonSize: CGFloat {
        switch font {
        case .caption, .caption2:
            return 10
        case .footnote:
            return 11
        case .subheadline:
            return 12
        case .callout:
            return 13
        case .body:
            return 14
        case .headline:
            return 16
        case .title3:
            return 18
        case .title2:
            return 20
        case .title:
            return 22
        case .largeTitle:
            return 26
        default:
            return 14
        }
    }
    
    var body: some View {
        Button(action: {
            // Haptic feedback
            let impactFeedback = UIImpactFeedbackGenerator(style: .light)
            impactFeedback.impactOccurred()
            
            // Open URL
            if UIApplication.shared.canOpenURL(url) {
                UIApplication.shared.open(url)
            }
        }) {
            Group {
                if let faviconImage = faviconImage {
                    Image(uiImage: faviconImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } else if isLoading {
                    // Show a small loading indicator
                    Circle()
                        .fill(Color.gray.opacity(0.3))
                        .overlay(
                            ProgressView()
                                .scaleEffect(0.4)
                                .tint(.gray)
                        )
                } else {
                    // Fallback icon
                    Image(systemName: "link.circle.fill")
                        .foregroundColor(.blue)
                        .font(.system(size: buttonSize * 0.8))
                }
            }
            .frame(width: buttonSize, height: buttonSize)
            .clipShape(Circle())
            .overlay(
                Circle()
                    .stroke(Color.primary.opacity(0.15), lineWidth: 0.5)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .padding(.horizontal, 1) // Minimal character-like spacing
        .onAppear {
            loadFavicon()
        }
    }
    
    private func loadFavicon() {
        guard let domain = url.host else { 
            isLoading = false
            return 
        }
        
        // Try to load favicon from Google's favicon service
        let faviconURLString = "https://www.google.com/s2/favicons?domain=\(domain)&sz=32"
        guard let faviconURL = URL(string: faviconURLString) else {
            isLoading = false
            return
        }
        
        print("üîç Loading favicon for: \(domain)")
        
        URLSession.shared.dataTask(with: faviconURL) { data, response, error in
            DispatchQueue.main.async {
                if let data = data, let image = UIImage(data: data), data.count > 100 { // Ensure it's not just a placeholder
                    print("‚úÖ Favicon loaded for: \(domain)")
                    faviconImage = image
                } else {
                    print("‚ùå Favicon failed for: \(domain)")
                }
                isLoading = false
            }
        }.resume()
    }
}

// MARK: - Rich Markdown View (Legacy - keeping for compatibility)
struct RichMarkdownView: View {
    let content: String
    
    var body: some View {
        MarkdownText(content)
    }
}

// MARK: - Preview
#Preview {
    ScrollView {
        VStack(alignment: .leading, spacing: 20) {
            MarkdownText("""
**Technology Summary**

**Key Developments**
‚Ä¢ **Apple releases** new AI chip for MacBooks <<https://apple.com>>
‚Ä¢ **Google announces** quantum computing breakthrough <<https://google.com>>
‚Ä¢ Microsoft partners with **OpenAI** for business tools <<https://microsoft.com>>

**Market Impact**
‚Ä¢ Tech stocks rise **5%** following announcements
‚Ä¢ AI startup funding reaches ***$50B*** in Q4 <<https://techcrunch.com>>
‚Ä¢ ***Record-breaking*** investment levels seen across the sector

**Looking Ahead**
‚Ä¢ CES 2024 expected to showcase **major innovations**
‚Ä¢ Regulatory frameworks under development <<https://reuters.com>>
‚Ä¢ Industry experts predict ***unprecedented growth*** in AI sector
""")
            .padding()
        }
    }
} 